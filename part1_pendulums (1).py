# -*- coding: utf-8 -*-
"""Part1_Pendulums.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QDiJnONzV1FerI0nWiUqaGd5wwqEy5QD

# Project Part 1 (10pts)
## ME 334: Advanced Dynamics, Control and System Identification
### Stanford University
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib notebook
# %matplotlib inline

!apt install texlive-fonts-recommended texlive-fonts-extra
!apt install dvipng
!apt-get install texlive-latex-extra texlive-fonts-recommended dvipng cm-super

"""# Pendulums Dynamics


<!--
![me334_project_dp.png](attachment:me334_project_dp.png)
![me334_project_trip_pend.png](attachment:me334_project_trip_pend.png)
-->
![me334_project_dp.png](attachment:me334_project_dp.png)
![me334_project_trip_pend.png](attachment:me334_project_trip_pend.png)

<!--
<div>
<img src="attachment:me334_project_dp.png" width="400">
</div>
<div>
<img src="attachment:me334_project_trip_pend.png" width="400">
</div>
-->

## Double Pendulum

### Theory
Derive the dynamics of the double pendulum system shown in using:
1. Newtons method
2. Euler-Lagrange method

All links are uniform rectangles with dimensions width, height, length: $(w\times h \times L)=(a\times a \times L_i)$.

### Simulate
1. Produce a dynamic function $\dot{s}(t) = f(s(t),p)$ where

    - The parameters of the system: $m_i, \mathcal{I}_i, L_i \,\,\forall i$, they will be in a parameter list $p = [p_1, \ldots, p_n]$ for $n$ links, where $p_i = [\underbrace{m_i}_{scalar}, \underbrace{L_i}_{scalar}, \underbrace{\mathcal{I}_i}_{\textit{matrix }3\times 3} ]$
    - For the state ${s} = \begin{bmatrix} \theta_{1} & \theta_{2} & \dot{\theta}_{1} & \dot{\theta}_{2}  \end{bmatrix}^T$ (where each $\theta_i$ is angle between the current frame and the $A$ frame), and you are given the current state ${s}(t)$

2. Simulate and Plot: plot your results, the states of the system (and if there was a control strategy the desired and actual trajectory of your system)


## Triple Pendulum

### Theory
Derive the dynamics of the triple pendulum system shown in \figref{fig:project_triple_pendulum}. All links are uniform rectangles with dimensions width, height, length: $(w\times h \times L)=(a\times a \times L_i)$.

### Simulate
1.  Produce a dynamic function $\dot{s}(t) = f(s(t),p)$ where
    - The parameters of the system: $m_i, \mathcal{I}_i, L_i \,\, \forall i$, they will be in a parameter list $p = [p_1, \ldots, p_n]$ for $n$ links, where $p_i = [\underbrace{m_i}_{scalar}, \underbrace{L_i}_{scalar}, \underbrace{\mathcal{I}_i}_{\textit{matrix }3\times 3} ]$
    - For the state ${s} = \begin{bmatrix} \theta_{1} & \theta_{2} & \theta_{3} & \dot{\theta}_{1} & \dot{\theta}_{2} & \dot{\theta}_{3} \end{bmatrix}^T$ (where each $\theta_i$ is angle between the current frame and the $A$ frame), given the current state ${s}(t)$

2. Simulate and Plot: plot your results, the states of the system (and if there was a control strategy the desired and actual trajectory of your system)


## Hints/tips
1. Please install the Tabulate package https://pypi.org/project/tabulate/
2. Feel free to add any additional functions you need to facilitate your solution
3. when submitting, if pdf does not generate automatically, leverage print-preview and scale for paper size.

"""

#!/usr/bin/env python
import numpy as np #import numpy as np means: import libary numpy and let me refer to it now on as 'np'
from scipy import integrate #this will allow us to perform integration (like matlab ode45)
from scipy.integrate import odeint
#The following will allow us to plot and animate
import matplotlib.pyplot as plt  #This is used for static graphs
from mpl_toolkits.mplot3d import Axes3D
import mpl_toolkits.mplot3d.axes3d as p3
# import matplotlib.animation as animation
from matplotlib import animation, rc #this will be used to play animations
rc('text', usetex=True) #if you want to use latex in plot legends
from sympy import *
import sympy as sp
#For displaying tables
from tabulate import tabulate

"""# Double Pendulum"""

#Set Parameters
def inertia_matrix_cm(L,W,H,m):
    '''
    Inertia matrix L on y axis, W on x axis and H on z axis
    m: mass (kg)
    Output: inertia matrix about the cm aligned with principle axis
    '''
    I = (m/12.0)*np.matrix([[L**2 + H**2,0,0],[0,W**2+H**2,0],[0,0,L**2+W**2]])
    return I

a1 = 0.1
L1 = 1.0
m1 = 3.0 #units kg
I1 = inertia_matrix_cm(L1,a1,a1,m1)

a2 = 0.1
L2 = 1.0
m2 = 2.0 #units kg
I2 = inertia_matrix_cm(L2,a2,a2,m2)

params_dp = {'link1':{'L':L1,'I':I1,'m':m1},
          'link2':{'L':L2,'I':I2,'m':m2}} #access example L1 = params['link1']['L']

print(I1)
print(I1[2,2])

"""## Insert your functions below for the Double Pendulum:"""

#Student Functions (please construct any additional functions you need in this block)

def double_pendulum_dyn(s, t, params):
    '''
    Input:
    - s: states of the system in numpy matrix (4x1 vector) [th1, th2, dth1, dth2]
    - params: dictionary of parameter values
    ------
    Output:
    - ds/dt: derivative states vector (4x1 vector) [dth1, dth2, ddth1, ddth2]
    '''
    # Unpack parameters
    L1 = params['link1']['L']
    L2 = params['link2']['L']
    m1 = params['link1']['m']
    m2 = params['link2']['m']
    I1z = params['link1']['I'][2, 2]
    I2z = params['link2']['I'][2, 2]
    g = 9.81  # gravity

    # Unpack state
    th1, th2, dth1, dth2 = s

    # EL for theta
    # 0 = I1z*ddth1 - 3*L1*sin(th1)/2 + L1**2*m1*ddth1/4 + L1**2*m2*ddth1 - L1*L2*m2*sin(th2-th1)*dth2**2/2 + L1*L2*m2*cos(th2-th1)*ddth2/2
    # EL for phi
    # 0 = m2*L2**2*ddth2/4 + L1*m1*cos(th2-th1)*L2*ddth1/2 + I2z*ddth2 + L1*m2*sin(th2-th1)*L2*dth1**2/2 - sin(th2)*L2/2

    A = np.array([[I1z +L1**2*m1/4 + L1**2*m2, L1*L2*m2*np.cos(th2-th1)/2],
                  [L1*L2*m2*np.cos(th2-th1)/2, I2z + m2*L2**2/4]])

    B = np.array([-L1*m1*g*np.sin(th1)/2 - L1*g*m2*np.sin(th1) - L1*L2*m2*np.sin(th2-th1)*dth2**2/2,
                  -m2*g*np.sin(th2)*L2/2 + L1*m2*np.sin(th2-th1)*L2*dth1**2/2])

    # Solving for ddth1 and ddth2
    ddth1, ddth2 = np.linalg.solve(A, B)

    # Return the derivative of the state
    dsdt = [dth1, dth2, ddth1, ddth2]
    return dsdt

def rot_z(theta):
    R = Matrix([
        [sp.cos(theta), -sp.sin(theta), 0],
        [sp.sin(theta), sp.cos(theta), 0],
        [0, 0, 1],
    ])
    return R



"""## Animate Dynamics:"""

#now make the time series
max_time = 30
Sec_sub = 20 #second subdivision (frequency/Hz)
dt = 1/Sec_sub #useful for the animation function
t = np.linspace(0,max_time,int(Sec_sub*max_time))

s2_init_list = [[0,0,0.6,0.8],
                [0,0,-0.6,-0.8],
                [np.pi/2,0,0,0],
                [np.pi/2,np.pi/2,0,0],
                [np.pi,np.pi/2,0,0],
                [np.pi/2,np.pi/2,1.6,-0.3]]

#integrate dynamics output
s2_t_list = []
for s2_0 in s2_init_list:
    s2_t_out = odeint(double_pendulum_dyn,s2_0,t, args=(params_dp,))
    s2_t_list.append(s2_t_out)

s2_t = s2_t_list[0]

#Now plot the angle vs time
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, autoscale_on=True) #if you want to strictly set the bounds
ax.grid() #this allows us to see the grid
ax.plot(t,s2_t[:,0],'r',label='$\\theta_1$') #Note: when using latex in legends, use double instead of single '\' for variables
ax.plot(t,s2_t[:,1],'g',label='$\\theta_2$') #Note: when using latex in legends, use double instead of single '\' for variables
ax.plot(t,s2_t[:,2],'-.r',label='$d\\theta_1$') #Note: when using latex in legends, use double instead of single '\' for variables
ax.plot(t,s2_t[:,3],'-.g',label='$d\\theta_2$') #Note: when using latex in legends, use double instead of single '\' for variables
ax.legend(); #show the legend

figdp, axdp = plt.subplots(6,1,figsize=(10, 8),sharey=True)
figdp.suptitle('Double Pendulum Initial Conditions',fontsize=16)

def dp_subfig_plots(ax_curr,s2_curr,t):
    ax_curr.grid()
    ax_curr.plot(t,s2_curr[:,0],'r',label='$\\theta_1$') #Note: when using latex in legends, use double instead of single '\' for variables
    ax_curr.plot(t,s2_curr[:,1],'g',label='$\\theta_2$') #Note: when using latex in legends, use double instead of single '\' for variables
    ax_curr.plot(t,s2_curr[:,2],'-.r',label='$d\\theta_1$') #Note: when using latex in legends, use double instead of single '\' for variables
    ax_curr.plot(t,s2_curr[:,3],'-.g',label='$d\\theta_2$') #Note: when using latex in legends, use double instead of single '\' for variables
    ax_curr.legend(fontsize='5'); #show the legend

for idx in range(6):
    ax_curr = axdp[idx]
    s2_curr = s2_t_list[idx]
    dp_subfig_plots(ax_curr,s2_curr,t)

#This is a grading tool, each column is the differential ds/dt for these intial conditions
ds_dp_list = []
for ss_test in s2_init_list:
    ds_test = double_pendulum_dyn(ss_test,0.0,params_dp)
    ds_dp_list.append(ds_test)
#rows have ds_dt for each initial condition, these need to be transposed to columns
ds_dp_list = np.array(ds_dp_list).T.tolist()
columns = ['IC 1','IC 2','IC 3','IC 4','IC 5','IC 6'] #initial condition indicies



plt.show() #this says display the info here
print(tabulate(ds_dp_list,headers=columns))

#Simulate Output
from matplotlib import animation, rc #this will be used to play animations
rc('text', usetex=True) #if you want to use latex in plot legends
from IPython.display import HTML #this is for rendering the animations

#Draw the objects
fig2 = plt.figure();
ax2 = fig2.add_subplot(111, autoscale_on=False, xlim=(-3.0, 3), ylim=(-3.0, 3.0));
ax2.set_aspect('equal')

frame_lengths = 1.0

#frames
frame_A_x, = ax2.plot([0,frame_lengths], [0,0], '-',color='red', lw=1)
frame_A_y, = ax2.plot([0,0], [0,frame_lengths], '-',color='green', lw=1)

frame_B_x, = ax2.plot([], [], '-',color='red', lw=1)
frame_B_y, = ax2.plot([], [], '-',color='green', lw=1)

frame_C_x, = ax2.plot([], [], '-',color='red', lw=1)
frame_C_y, = ax2.plot([], [], '-',color='green', lw=1)



#define animation structions
link1, = ax2.plot([], [], '-',color='red', lw=5)
link2, = ax2.plot([], [], '-',color='green', lw=5)
time_template = 'time = %.1fs';
time_text = ax2.text(0.05, 0.9, '', transform=ax2.transAxes); #sim time object, with location description

def rot_z_axis(th):
    R = np.matrix([[np.cos(th), -np.sin(th),0],
                   [np.sin(th), np.cos(th),0],
                   [0,0,1]])
    #this rotates a frame from F back to A through angle th on the z-axis
    return R

def draw_frames(origin, z_axis_rotation_angle):
    #leveraging the fact that all axis undergo rotation about the z axis
    y_local = np.matrix([0,1,0]).T
    x_local = np.matrix([1,0,0]).T
    th = z_axis_rotation_angle
    R = rot_z_axis(th)
    y_rot = R*y_local
    x_rot = R*x_local
    y_rot_vect = [[origin.item(0),origin.item(0)+y_rot.item(0)],
                  [origin.item(1),origin.item(1)+y_rot.item(1)]]

    x_rot_vect = [[origin.item(0),origin.item(0)+x_rot.item(0)],
                  [origin.item(1),origin.item(1)+x_rot.item(1)]]

    return x_rot_vect,y_rot_vect

def pendulum_link_ani(p_init, p_final):
    link_x = [p_init.item(0),p_final.item(0)]
    link_y = [p_init.item(1),p_final.item(1)]
    return link_x, link_y

def update_pendulum(i,link1,link2,params_dp):
    th1,th2,dth1,dth2 = s2_t[i,:]

    P0 = np.matrix([0,0,0]).T

    R_BA = rot_z_axis(th1)
    L1 = params_dp['link1']['L']
    P1_local = np.matrix([0,-L1,0]).T
    P1 = R_BA*P1_local

    R_CA = rot_z_axis(th2)
    L2 = params_dp['link2']['L']
    P2_local = np.matrix([0,-L2,0]).T
    P2 = R_CA*P2_local + P1

    #obtain reference frame vectors
    B_x_vec,B_y_vec = draw_frames(P0,th1)
    C_x_vec,C_y_vec = draw_frames(P1,th2)

    #Now update the frames
    frame_A_x.set_data([0,frame_lengths], [0,0])
    frame_A_y.set_data([0,0], [0,frame_lengths])
    frame_B_x.set_data(B_x_vec[0],B_x_vec[1])
    frame_B_y.set_data(B_y_vec[0],B_y_vec[1])
    frame_C_x.set_data(C_x_vec[0],C_x_vec[1])
    frame_C_y.set_data(C_y_vec[0],C_y_vec[1])

    #Now draw the pendulum
    link1.set_data(pendulum_link_ani(P0,P1))
    link2.set_data(pendulum_link_ani(P1,P2))

    time_text.set_text(time_template % (i*dt))
    return [link1, link2],time_text

dp_ani = animation.FuncAnimation(fig2, update_pendulum, np.arange(1, len(t)) , fargs=(link1, link2,params_dp),
                                   interval=50, blit=False)

# plt.show()
rc('animation', html='jshtml')
dp_ani

"""# Triple Pendulum

"""

def inertia_matrix_cm(L,W,H,m):
    '''
    Inertia matrix L on y axis, W on x axis and H on z axis
    m: mass (kg)
    Output: inertia matrix about the cm aligned with principle axis
    '''

    I = (m/12.0)*np.matrix([[L**2 + H**2,0,0],[0,W**2+H**2,0],[0,0,L**2+W**2]])
    return I
#Set Parameters
a1 = 0.1
L1 = 1.3
m1 = 3.0 #units kg
I1 = inertia_matrix_cm(L1,a1,a1,m1)

a2 = 0.1
L2 = 0.9
m2 = 3.0 #units kg
I2 = inertia_matrix_cm(L2,a2,a2,m2)

a3 = 0.1
L3 = 0.8
m3 = 3.0 #units kg
I3 = inertia_matrix_cm(L3,a3,a3,m3)


params_tp = {'link1':{'L':L1,'I':I1,'m':m1},
             'link2':{'L':L2,'I':I2,'m':m2},
             'link3':{'L':L3,'I':I3,'m':m3}} #access example L1 = params['link1']['L']

"""## Insert your functions below for the Triple Pendulum:"""

#Student Functions (please construct any additional functions you need in this block)

def triple_pendulum_dyn(s,t,params):
    '''
    Input:
    - s: states of the system in numpy matrix (6x1 vector) [th1, th2, th3, dth1, dth2, dth3]
    - params: dictionary of parameter values
    ------
    Output:
    - ds/dt: derivative states vector (6x1 vector) [dth1, dth2, dth3, ddth1, ddth2, ddth3]
    '''
    # Unpack state
    th1, th2, th3, dth1, dth2, dth3 = s
    L1 = params['link1']['L']
    L2 = params['link2']['L']
    L3 = params['link3']['L']
    m1 = params['link1']['m']
    m2 = params['link2']['m']
    m3 = params['link3']['m']
    I1z = params['link1']['I'][2, 2]
    I2z = params['link2']['I'][2, 2]
    I3z = params['link3']['I'][2, 2]
    g = 9.81  # gravity

    # Evaluate the solutions at the current state
    A = np.array([
        [I1z + L1**2*m1/4 + L1**2*m2 + L1**2*m3, L1*L2*m2/2*np.cos(th2-th1) + L1*L2*m3*np.cos(th2-th1), L1*L3/2*m3*np.cos(th3-th1)],
        [L1*L2*m2/2*np.cos(th2-th1) + L1*L2*m3*np.cos(th2-th1), I2z + L2**2*m2/4 + L2**2*m3, L2*L3*m3*np.cos(th3-th2)/2],
        [L1*L3/2*m3*np.cos(th3-th1), L2*L3*m3*np.cos(th3-th2)/2, I3z + L3**2*m3/4]
    ])

    B = np.array([
        -(L1 * g * m1 * np.sin(th1) / 2 + L1 * g * m2 * np.sin(th1) + L1 * g * m3 * np.sin(th1) - L1 * L3 / 2 * m3 * np.sin(th3 - th1) * dth3**2 - L1 * L2 / 2 * m2 * np.sin(th2 - th1) * dth2**2 - L1 * L2 * m3 * np.sin(th2 - th1) * dth2**2),
        -(L2 * g * m2 * np.sin(th2) / 2 + L2 * g * m3 * np.sin(th2) - L2 * L3 * m3 * np.sin(th3 - th2) * dth3**2 / 2 + L1 * L2 * m2 * np.sin(th2 - th1) * dth1**2 / 2 + L1 * L2 * m3 * np.sin(th2 - th1) * dth1**2),
        -(L3 * g * m3 * np.sin(th3) / 2 + L2 * L3 * m3 / 2 * np.sin(th3 - th2) * dth2**2 + L1 * L3 * m3 * np.sin(th3 - th1) * dth1**2 / 2)
    ])

    # Solving for ddth1, ddth2, ddth3
    ddth = np.linalg.solve(A, B)

    ddth1 = ddth[0]
    ddth2 = ddth[1]
    ddth3 = ddth[2]
    # Return the derivative of the state
    dsdt = [dth1, dth2, dth3, ddth1, ddth2, ddth3]
    return dsdt

"""## Animate Dynamics:"""

#now make the time series
max_time = 30
Sec_sub = 20 #second subdivision (frequency/Hz)
dt = 1/Sec_sub #useful for the animation function
t = np.linspace(0,max_time,int(Sec_sub*max_time))

s3_init_list = [[0,0,0,0.6,0.8,0.4],
                [0,0,0,-0.6,-0.8,0.5],
                [np.pi/2,0,0,0,0,0],
                [np.pi/2,np.pi/2,0,0,0,0],
                [np.pi,np.pi/2,0,0,0,0],
                [np.pi/2,np.pi/2,np.pi/3,1.6,-0.3,0.4]]

#integrate dynamics output
s3_t_list = []
for s3_0 in s3_init_list:
    s3_t_out = odeint(triple_pendulum_dyn,s3_0,t, args=(params_tp,))
    s3_t_list.append(s3_t_out)

s3_t = s3_t_list[0] #animate these initial conditions

#Now plot the angle vs time
fig3 = plt.figure(figsize=(10, 8))
ax3 = fig3.add_subplot(111, autoscale_on=True) #if you want to strictly set the bounds
ax3.grid() #this allows us to see the grid
ax3.plot(t,s3_t[:,0],'r',label='$\\theta_1$') #Note: when using latex in legends, use double instead of single '\' for variables
ax3.plot(t,s3_t[:,1],'g',label='$\\theta_2$') #Note: when using latex in legends, use double instead of single '\' for variables
ax3.plot(t,s3_t[:,2],'b',label='$\\theta_3$') #Note: when using latex in legends, use double instead of single '\' for variables

ax3.plot(t,s3_t[:,3],'-.r',label='$d\\theta_1$') #Note: when using latex in legends, use double instead of single '\' for variables
ax3.plot(t,s3_t[:,4],'-.g',label='$d\\theta_2$') #Note: when using latex in legends, use double instead of single '\' for variables
ax3.plot(t,s3_t[:,5],'-.b',label='$d\\theta_3$') #Note: when using latex in legends, use double instead of single '\' for variables

ax3.legend(loc="upper right"); #show the legend

figtp, axtp = plt.subplots(6,1,figsize=(10, 8),sharey=True)
figtp.suptitle('Triple Pendulum Initial Conditions',fontsize=16)

def tp_subfig_plots(ax_curr,s3_curr,t):
    ax_curr.grid()
    ax_curr.plot(t,s3_curr[:,0],'r',label='$\\theta_1$') #Note: when using latex in legends, use double instead of single '\' for variables
    ax_curr.plot(t,s3_curr[:,1],'g',label='$\\theta_2$') #Note: when using latex in legends, use double instead of single '\' for variables
    ax_curr.plot(t,s3_curr[:,2],'b',label='$\\theta_3$') #Note: when using latex in legends, use double instead of single '\' for variables
    ax_curr.plot(t,s3_curr[:,3],'-.r',label='$d\\theta_1$') #Note: when using latex in legends, use double instead of single '\' for variables
    ax_curr.plot(t,s3_curr[:,4],'-.g',label='$d\\theta_2$') #Note: when using latex in legends, use double instead of single '\' for variables
    ax_curr.plot(t,s3_curr[:,5],'-.b',label='$d\\theta_3$') #Note: when using latex in legends, use double instead of single '\' for variables
    ax_curr.legend(fontsize='5'); #show the legend

for idx in range(6):
    ax_curr = axtp[idx]
    s3_curr = s3_t_list[idx]
    tp_subfig_plots(ax_curr,s3_curr,t)


#This is a grading tool, each column is the differential ds/dt for these intial conditions
ds_tp_list = []
for ss_test in s3_init_list:
    ds_test = triple_pendulum_dyn(ss_test,0.0,params_tp)
    ds_tp_list.append(ds_test)
#rows have ds_dt for each initial condition, these need to be transposed to columns
ds_tp_list = np.array(ds_tp_list).T.tolist()
columns = ['IC 1','IC 2','IC 3','IC 4','IC 5','IC 6'] #initial condition indicies



plt.show() #this says display the info here
#This is a grading tool, each column is the differential ds/dt for these intial conditions
print(tabulate(ds_tp_list,headers=columns))

#Simulate Output

#Simulate Output
from matplotlib import animation, rc #this will be used to play animations
rc('text', usetex=True) #if you want to use latex in plot legends
from IPython.display import HTML #this is for rendering the animations

#Draw the objects
fig4 = plt.figure();
ax4 = fig4.add_subplot(111, autoscale_on=False, xlim=(-3.0, 3), ylim=(-3.0, 3.0));
ax4.set_aspect('equal')

frame_lengths = 1.0

#frames
frame_A_x_tp, = ax4.plot([0,frame_lengths], [0,0], '-',color='red', lw=1)
frame_A_y_tp, = ax4.plot([0,0], [0,frame_lengths], '-',color='green', lw=1)

frame_B_x_tp, = ax4.plot([], [], '-',color='red', lw=1)
frame_B_y_tp, = ax4.plot([], [], '-',color='green', lw=1)

frame_C_x_tp, = ax4.plot([], [], '-',color='red', lw=1)
frame_C_y_tp, = ax4.plot([], [], '-',color='green', lw=1)

frame_D_x_tp, = ax4.plot([], [], '-',color='red', lw=1)
frame_D_y_tp, = ax4.plot([], [], '-',color='green', lw=1)




#define animation structions
link1_tp, = ax4.plot([], [], '-',color='red', lw=3)
link2_tp, = ax4.plot([], [], '-',color='green', lw=3)
link3_tp, = ax4.plot([], [], '-',color='blue', lw=3)

time_template = 'time = %.1fs';
time_text_tp = ax4.text(0.05, 0.9, '', transform=ax4.transAxes); #sim time object, with location description

def rot_z_axis(th):
    R = np.matrix([[np.cos(th), -np.sin(th),0],
                   [np.sin(th), np.cos(th),0],
                   [0,0,1]])
    #this rotates a frame from F back to A through angle th on the z-axis
    return R

def draw_frames(origin, z_axis_rotation_angle):
    #leveraging the fact that all axis undergo rotation about the z axis
    y_local = np.matrix([0,1,0]).T
    x_local = np.matrix([1,0,0]).T
    th = z_axis_rotation_angle
    R = rot_z_axis(th)
    y_rot = R*y_local
    x_rot = R*x_local
    y_rot_vect = [[origin.item(0),origin.item(0)+y_rot.item(0)],
                  [origin.item(1),origin.item(1)+y_rot.item(1)]]

    x_rot_vect = [[origin.item(0),origin.item(0)+x_rot.item(0)],
                  [origin.item(1),origin.item(1)+x_rot.item(1)]]

    return x_rot_vect,y_rot_vect

def pendulum_link_ani(p_init, p_final):
    link_x = [p_init.item(0),p_final.item(0)]
    link_y = [p_init.item(1),p_final.item(1)]
    return link_x, link_y

def update_pendulum(i,link1_tp,link2_tp,link3_tp,params_tp):
    th1,th2,th3,dth1,dth2,dth3 = s3_t[i,:]

    P0 = np.matrix([0,0,0]).T

    R_BA = rot_z_axis(th1)
    L1 = params_tp['link1']['L']
    P1_local = np.matrix([0,-L1,0]).T
    P1 = R_BA*P1_local

    R_CA = rot_z_axis(th2)
    L2 = params_tp['link2']['L']
    P2_local = np.matrix([0,-L2,0]).T
    P2 = R_CA*P2_local + P1

    R_DA = rot_z_axis(th3)
    L3 = params_tp['link3']['L']
    P3_local = np.matrix([0,-L3,0]).T
    P3 = R_DA*P3_local + P2

    B_x_vec,B_y_vec = draw_frames(P0,th1)
    C_x_vec,C_y_vec = draw_frames(P1,th2)
    D_x_vec,D_y_vec = draw_frames(P2,th3)


    #Now update the frames
    frame_A_x_tp.set_data([0,frame_lengths], [0,0])
    frame_A_y_tp.set_data([0,0], [0,frame_lengths])
    frame_B_x_tp.set_data(B_x_vec[0],B_x_vec[1])
    frame_B_y_tp.set_data(B_y_vec[0],B_y_vec[1])
    frame_C_x_tp.set_data(C_x_vec[0],C_x_vec[1])
    frame_C_y_tp.set_data(C_y_vec[0],C_y_vec[1])
    frame_D_x_tp.set_data(D_x_vec[0],D_x_vec[1])
    frame_D_y_tp.set_data(D_y_vec[0],D_y_vec[1])

    #Now draw the pendulum
    link1_tp.set_data(pendulum_link_ani(P0,P1))
    link2_tp.set_data(pendulum_link_ani(P1,P2))
    link3_tp.set_data(pendulum_link_ani(P2,P3))


    time_text_tp.set_text(time_template % (i*dt))
    return [link1_tp, link2_tp, link3_tp],time_text_tp

robot_ani = animation.FuncAnimation(fig4, update_pendulum, np.arange(1, len(t)) , fargs=(link1_tp, link2_tp, link3_tp,params_tp),
                                   interval=50, blit=False)

rc('animation', html='jshtml')
robot_ani